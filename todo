## Phase 1 â€” Email foundations & `gomailer`

**Learn**

- SMTP handshake, TLS, app passwords.
- API providers vs SMTP, deliverability trade-offs.

**Build**

1. **`pkg/gomailer` library**

   - `Mailer` interface: `Send(Email) error`.
   - Models: `Email{From, To, Subject, Text, HTML, Attachments}`.
   - Drivers:

     - **SMTP driver** (works with Gmail or any SMTP; test with Mailpit).
     - **Sendgrid driver** (REST API).

   - Functional options (timeouts, headers), context support.
   - Idempotency (optional header pass-through).
   - Unit tests with fakes; example program in `/examples/gomailer`.

2. **Email worker (first real microservice)**

   - Kafka consumer group `notifications.email`.
   - Reads JSON `{id, tenant, to, subject, templates, data, idempotencyKey}`.
   - Uses `gomailer` with provider selection via config.
   - Retries (exponential + jitter), DLQ on permanent failure.
   - Prometheus metrics:

     - `notification_send_total{channel="email",provider,tenant,status}`
     - `notification_send_duration_seconds_bucket{channel="email",provider}`
     - `notification_retry_total{channel="email",reason}`

   - Logs in JSON (zap), correlation ID.

**Outcome**: `curl` â†’ Kafka â†’ Email worker â†’ message lands in Mailpit. Grafana shows counts & latency.

---

## Phase 2 â€” SMS foundations & `gosms`

**Learn**

- E.164, provider APIs, DLR semantics, inbound webhooks.

**Build**

1. **`pkg/gosms`** with interface `Send(to, body)`.

   - Drivers: **Twilio** + **VHMAC proves body wasnâ€™t tamperedonage** (config-switchable).
   - Normalize numbers to E.164; validate early.

2. **SMS worker**

   - Kafka consumer group `notifications.sms`.
   - Retry & DLQ like email; per-tenant throttle (simple token bucket in memory).
   - **DLR webhook** endpoint in API to mark â€œdelivered/failedâ€ asynchronously.

**Outcome**: End-to-end SMS via Twilio sandbox; delivery status flows back into DB via webhook.

---

## Phase 3 â€” Notification API (publisher + admin)

**Learn**

- REST, OpenAPI; API keys & HMAC signing; idempotency.

**Build**

- `/publish/:topic` (generic) and `/notify` (policy-driven fan-out) endpoints.
- Request schema includes `idempotency_key`, tenant, user contact info, channel overrides, and template data.
- API Keys table (tenant, key hash, scopes, rate limit).
- Middlewares: auth, rate limit (token bucket), idempotency store (Redis or Postgres unique index).
- OpenAPI spec + Swagger UI.
- Producer: idempotent Kafka producer keyed by tenant+user to preserve per-user order.

**Outcome**: A single HTTP call can fan out to email+SMS topics, keys are validated, and duplicates are coalesced.

---

## Phase 4 â€” Persistence & query surface

**Learn**

- DB schema versioning, indexing for search, SLOs on queries.

**Build**

- Tables:

  - `notifications(id, tenant, topic, user_ref, created_at, status)`
  - `delivery_attempts(id, notification_id, channel, provider, status, error, try, latency_ms, created_at)`
  - `api_keys(id, tenant, hash, scopes, created_at, last_used_at)`
  - `templates(id, tenant, channel, name, version, engine, content, created_at)`

- Repos + migrations (goose/golang-migrate).
- API:

  - `GET /notifications/:id`
  - `GET /notifications?tenant=&status=&channel=&user=&limit=&cursor=`
  - `POST /notifications/:id/redrive` (from DLQ)

  **Outcome**: You can see history and redrive failed ones.

---

## Phase 5 â€” Templates, localization, preferences

**Learn**

- Go templates/Mustache, MJML â†’ HTML; i18n patterns; DND windows.

**Build**

- Template engine abstraction: `Render(channel, name, locale, data) (Text, HTML)`.
- Store templates in DB; optional filesystem loader for local dev.
- User preferences: opt-outs per channel, quiet hours (timezone aware).
- Policy engine: â€œfor topic X â†’ channels \[email, sms] unless user opted-outâ€.

**Outcome**: Customizable content per tenant/locale with user-friendly opt-outs.

---

## Phase 6 â€” Observability & tracing (deep)

**Learn**

- Metric cardinality limits, RED/USE metrics; OpenTelemetry spans.

**Build**

- Standard metrics in all services:

  - `http_requests_total{route,code}`
  - `kafka_consumer_lag{group,topic,partition}`
  - The channel metrics from earlier

- Tracing:

  - Span chain: API receive â†’ Kafka produce â†’ worker consume â†’ provider call.
  - OTel Collector + Jaeger/Tempo.

- Grafana dashboards:

  - API throughput, P95 latency.
  - Per-channel success/failure.
  - Kafka lag & rebalance count.
  - Provider latency compare (Mailgun vs SendGrid, Twilio vs Vonage).

**Outcome**: Click a trace and see the full lifecycle of one notification.

---

## Phase 7 â€” Multi-tenant & quotas (SaaS-ready)

**Learn**

- Tenant isolation models, per-tenant quotas, noisy neighbor control.

**Build**

- Tenant scoping on reads/writes; row-level security rules (optional).
- Rate limit & quota counters by tenant.
- Usage meter: `tenant_usage_total{tenant,channel}`.
- Key rotation endpoints (create/revoke).

  **Outcome**: Safe to host multiple apps on one cluster.

---

## Phase 8 â€” Push & Chat channels

**Learn**

- FCM topics & device tokens; APNs JWT; Web Push VAPID; Slack webhook payloads.

**Build**

- `gopush` abstraction: `Send(device, title, body, data)`.

  - Drivers: FCM (first), APNs, Web Push.

- Push worker: `notifications.push`.
- Slack worker: `notifications.slack` via webhook.
- Device token registry (userâ†’tokens) with expiration and cleanup.

**Outcome**: One publish can hit Email + SMS + Push + Slack.

---

## Phase 9 â€” Reliability extras & ops

**Learn**

- Replay vs redrive; exactly-once with Kafka transactions (trade-offs); outbox pattern.

**Build**

- Replay tool: re-publish from a time window or by query.
- Redrive API from DLQ with optional re-templating.
- TTL for topics; compaction for idempotency keys.
- Lag alerts; KEDA autoscaling on consumer lag.

**Outcome**: Operable in the real world.

---

## Phase 10 â€” Packaging, deployment, examples, docs

**Learn**

- Helm chart authoring; secrets; overlays; image hardening.

**Build**

- Minimal images (distroless or alpine), non-root user.
- `docker-compose` quickstart with Mailpit.
- Helm chart with values for providers, Postgres, Kafka endpoints.
- GitHub Actions: lint â†’ test â†’ build images â†’ SBOM â†’ scan â†’ push â†’ publish Helm chart.
- `/examples` clients in Go/Node/TS with a 10-line â€œsend a notificationâ€ snippet.
- README with quickstart, architecture diagram, dashboards, and â€œwhyâ€.

**Outcome**: Anyone can clone â†’ run â†’ send a notification in minutes.

---

### Phase 1 â€” `gomailer` + Email worker

- [x] Define `Mailer` interface and `Email` model.
- [x] Implement **SMTP** driver (tested against Mailpit + Gmail app password).
- [x] Implement **Mailgun** driver.
- [x] Context timeouts, retries at library level (optional).
- [x] Unit tests with provider fakes.
- [x] Email worker consumes `notifications.email` with retry + DLQ.
- [x] Prometheus metrics; JSON logs; config for primary/fallback provider.

### Phase 2 â€” `gosms` + SMS worker

- [x] Define interface and Twilio+Vonage drivers.
- [x] Normalize E.164 and validate.
- [ ] DLR webhook and status updates.
- [x] SMS worker with retry + DLQ + per-tenant rate limit.
- [x] Metrics
- [ ] Tests

### Phase 3 â€” API

- [x] `/publish/:topic` and `/notify` (policy fan-out).
- [x] API key auth
- [x] short term rate limit middleware.
- [x] long term rate limit middleware.
- [x] Idempotency keys (DB unique index + cache).
- [x] OpenAPI spec + Swagger UI.
- [x] Idempotent Kafka producer keyed by user.

### Phase 4 â€” Persistence

- [x] Postgres schema for notifications, attempts, keys, templates.
- [ ] Migrations with goose/golang-migrate.
- [x] `GET /notifications/:id` and search with pagination.
- [x] `POST /notifications/:id/redrive`.

### Phase 5 â€” Templates & prefs

- [x] Template storage; engines (Go tmpl)
- [ ] MJML pipeline.
- [x] Localization field and selection.
- [ ] Opt-out table and DND windows (tz aware).
- [x] Policy engine (topic â†’ channels, honoring prefs).

### Phase 6 â€” Observability

- [x] Standardize metrics names/labels.
- [x] OTel tracing across services.
- [x] Grafana dashboards for API, channels, Kafka lag, providers.
- [x] Alerting rules for failure rates & lag.

### Phase 7 â€” Multi-tenant

- [x] Tenant column everywhere;
- [x] scoped queries.(almost)
- [x] Quotas & per-tenant rate limits.
- [ ] API key rotation endpoints.
- [ ] Usage metrics and basic billing counters.

### Phase 8 â€” Push & Chat

- [ ] `gopush` with FCM (first), then APNs, Web Push.
- [ ] Push worker & token registry.
- [ ] Slack worker via webhook + formatting helpers.

### Phase 9 â€” Reliability & ops

- [ ] Replay tool (time range / query).
- [ ] Redrive from DLQ with filter conditions.
- [ ] Topic compaction for idempotency keys.
- [ ] Autoscaling on lag (KEDA); lag/failure alerts.

### Phase 10 â€” Packaging & docs

- [ ] Distroless images; non-root user.
- [ ] Helm chart with values; secrets guidance.
- [ ] GitHub Actions pipeline (lint/test/build/publish/scan).
- [ ] Examples in Go/Node/TS.
- [ ] README with diagram, quickstart, dashboards, and provider setup guides.
- [ ] CONTRIBUTING.md, CODE_OF_CONDUCT.md, Apache-2.0 license.

---

# ğŸ§  Distributed Notification System â€” Master Roadmap (v2)

### ğŸ©µ Goal

A **multi-channel, multi-tenant, Kafka-backed notification delivery platform** with strong reliability, observability, and real-world production patterns.

---

## âœ… Phase 1 â€” Email Foundations & `gomailer`

**Learn**

- SMTP handshake, TLS, app passwords, connection pools.
- Compare API-based vs SMTP-based delivery for reliability & throughput.

**Build**

1. **`pkg/gomailer` Library**

   - âœ… `Mailer` interface: `Send(ctx context.Context, Email) error`
   - âœ… Models: `Email{From, To, Subject, Text, HTML, Attachments}`
   - âœ… Drivers:

     - SMTP driver (Mailpit + Gmail)
     - Mailgun or SendGrid driver (configurable)

   - âœ… Functional options: timeouts, headers, retry policies
   - âœ… Context support + structured errors
   - âœ… Unit tests with mocks/fakes; example app under `/examples/gomailer`
   - ğŸ” **TODO:** Add pooled connections & delivery metrics per provider

2. **Email Worker**

   - âœ… Kafka consumer group `notifications.email`
   - âœ… Retries (exponential + jitter) + DLQ
   - âœ… Prometheus metrics:

     ```
     notification_send_total{channel="email",provider,tenant,status}
     notification_send_duration_seconds_bucket{channel="email",provider}
     notification_retry_total{channel="email",reason}
     ```

   - âœ… JSON logs with correlation IDs (zap)
   - ğŸ” **TODO:** Batch processing + DLQ replay tool

**Outcome:**
`curl â†’ API â†’ Kafka â†’ Email worker â†’ Mailpit` works, Grafana shows throughput & latency.

---

## âœ… Phase 2 â€” SMS Foundations & `gosms`

**Learn**

- E.164 formatting, DLR (Delivery Receipts), idempotent provider calls.

**Build**

1. **`pkg/gosms`**

   - âœ… Interface: `Send(ctx, to, body)`
   - âœ… Drivers: Twilio + Vonage (configurable)
   - âœ… Normalize & validate phone numbers (E.164)
   - ğŸ” **TODO:** Add provider HMAC validation for DLR webhooks

2. **SMS Worker**

   - âœ… Kafka group `notifications.sms`
   - âœ… Retry + DLQ
   - âœ… Per-tenant token bucket throttling
   - ğŸ” **TODO:** Implement DLR webhook â†’ update delivery status in DB
   - ğŸ” **TODO:** End-to-end tests + provider sandbox verification

**Outcome:**
Full SMS pipeline operational with rate limiting & provider metrics.

---

## âœ… Phase 3 â€” Notification API (Publisher + Admin)

**Learn**

- REST API design, HMAC signing, OpenAPI docs, API key management.

**Build**

- âœ… `/publish/:topic` & `/notify` fan-out endpoints
- âœ… API key auth & scopes
- âœ… Rate limiting (short + long window)
- âœ… Idempotency (Redis + Postgres unique index)
- âœ… OpenAPI + Swagger UI
- âœ… Idempotent Kafka producer keyed by user for order guarantees
- ğŸ” **TODO:** Add tenant-aware per-key quotas & analytics endpoint (`/usage`)

**Outcome:**
Single API call â†’ fan-out across channels, fully deduplicated.

---

## âœ… Phase 4 â€” Persistence & Query Surface

**Learn**

- Schema design, partitioning, migrations, query performance.

**Build**

- âœ… Tables:

  - `notifications`
  - `delivery_attempts`
  - `api_keys`
  - `templates`

- âœ… Repos + queries
- ğŸ” **TODO:** Migrations via `golang-migrate`
- âœ… APIs:

  - `GET /notifications/:id`
  - `GET /notifications?...filters`
  - `POST /notifications/:id/redrive`

- ğŸ” **TODO:** Index optimization & pagination cursor by `created_at`

**Outcome:**
You can browse & redrive failed notifications safely.

---

## âœ… Phase 5 â€” Templates, Localization & Preferences

**Learn**

- Templating engines, MJML, i18n patterns, user opt-out systems.

**Build**

- âœ… Template storage & Go `text/template` engine
- ğŸ” **TODO:** MJML-to-HTML pipeline for rich email templates
- âœ… Localization field & language selection
- ğŸ” **TODO:** User opt-out & quiet-hours (DND windows, timezone-aware)
- âœ… Policy engine (topic â†’ channels respecting prefs)

**Outcome:**
Per-tenant custom templates + localized rendering.

---

## âœ… Phase 6 â€” Observability & Tracing

**Learn**

- RED/USE metrics, OTel tracing, Grafana dashboards.

**Build**

- âœ… Standard metrics across all services:

  - `http_requests_total`
  - `kafka_consumer_lag`
  - `notification_*`

- âœ… OpenTelemetry tracing:

  - Span chain: API â†’ Kafka â†’ Worker â†’ Provider

- âœ… Grafana dashboards (API, channel latency, Kafka lag)
- âœ… Alerting rules (lag, failure rate)
- ğŸ” **TODO:** Tempo/Jaeger full-trace visualization polish

**Outcome:**
You can trace a notificationâ€™s full journey in Grafana/Jaeger.

---

## âœ… Phase 7 â€” Multi-Tenant & Quotas

**Learn**

- Tenant isolation, rate limiting, quotas, and billing.

**Build**

- âœ… Tenant scoping everywhere
- âœ… Per-tenant rate limiters
- ğŸ” **TODO:** API key rotation endpoints
- ğŸ” **TODO:** Usage metrics (`tenant_usage_total{tenant,channel}`)
- ğŸ” **TODO:** Optional row-level security enforcement (Postgres RLS)

**Outcome:**
Safe, isolated tenants â€” SaaS-ready.

---

## ğŸ” Phase 8 â€” Push & Chat Channels

**Learn**

- FCM, APNs, Web Push VAPID, Slack webhooks.

**Build**

- ğŸ” `gopush` interface â†’ drivers (FCM â†’ APNs â†’ Web Push)
- ğŸ” Push worker (`notifications.push`)
- ğŸ” Slack worker (`notifications.slack`)
- ğŸ” Device token registry with expiry + cleanup cron

**Outcome:**
Unified delivery: email + SMS + push + Slack.

---

## ğŸ” Phase 9 â€” Reliability & Ops

**Learn**

- Kafka transactions, replay/redrive semantics, idempotency compaction.

**Build**

- ğŸ” Replay tool (by time or filters)
- ğŸ” DLQ redrive with re-templating
- ğŸ” Topic compaction for idempotency keys
- ğŸ” KEDA autoscaling on lag
- ğŸ” Alerting for consumer lag & failures

**Outcome:**
Battle-tested reliability and scalability under load.

---

## ğŸ” Phase 10 â€” Packaging, Deployment, Docs

**Learn**

- Helm charts, security, container hardening, CI/CD pipelines.

**Build**

- ğŸ” Distroless images, non-root users
- ğŸ” Helm chart with provider configs & secrets
- ğŸ” GitHub Actions pipeline:

  - Lint â†’ Test â†’ Build â†’ SBOM â†’ Scan â†’ Push â†’ Publish chart

- ğŸ” `/examples` in Go + Node.js showing notification publish flow
- ğŸ” Full README:

  - Architecture diagram
  - Quickstart (docker-compose)
  - Grafana dashboards
  - Provider setup guide

- ğŸ” CONTRIBUTING.md, CODE_OF_CONDUCT.md, Apache-2.0 license

**Outcome:**
One-line deploy. Anyone can clone â†’ run â†’ send notifications in minutes.

---

## ğŸ§© Bonus (Optional Extensions)

| Extension                 | Description                                       |
| ------------------------- | ------------------------------------------------- |
| **Exactly-once delivery** | Kafka transactional producer + dedup store        |
| **Dynamic routing rules** | Tenants can define routing policies via config    |
| **Webhook notifications** | Third-party endpoints as channels                 |
| **Load tests**            | k6 or Vegeta benchmarks up to 50k events/sec      |
| **Chaos testing**         | Kill workers randomly, ensure redrive correctness |

---
