Version 1:

## **Phase 1: Go, REST APIs & Docker (Days 1‚Äì5)**

- [x] Create a basic Go REST API with `/health` and `/notify/test` routes
- [x] Parse POST request JSON and print the result in the terminal
- [x] Write a Dockerfile for the service (`FROM golang`, `COPY`, `RUN go build`)
- [x] Build and run the service with Docker (`docker build`, `docker run`)
- [x] Push your code to a public or private GitHub repo

---

## **Phase 2: Kafka and First Microservice (Days 6‚Äì12)**

- [x] Create a Docker Compose file with Kafka + Zookeeper
- [x] Update your Notification API:

  - [x] Add `/notify/signup` endpoint ‚Üí Publish event to Kafka topic `user_signup`

- [x] Create your second Go service ‚Üí **Email Worker**

  - [x] Subscribe to `user_signup` topic ‚Üí Print `"Sending Welcome Email to <user>"` on message receipt

- [x] Manually test: Call `/notify/signup`, verify Email Worker prints the message

---

## **Phase 3: Integrate Real Email/SMS APIs (Days 13‚Äì20)**

- [x] Replace the print statement with actual Mailgun API call to send welcome email

- [x] Create a **SMS Worker** microservice:

  - [x] Subscribe to `user_signup` topic
  - [x] Send SMS via Twilio API

- [x] Add `/notify/payment_success` to Notification API ‚Üí Publish to `payment_success` topic
- [x] Test end-to-end:

  - [x] API ‚Üí Kafka ‚Üí Email Worker (Mailgun email sent)
  - [x] API ‚Üí Kafka ‚Üí SMS Worker (Twilio SMS sent)

- [x] Run all services + Kafka using `docker-compose up`

---

## **Phase 4: Observability & Logging (Days 21‚Äì26)**

- [x] Add a `/metrics` endpoint to Notification API and workers (export Go metrics)
- [x] Setup Prometheus to scrape all your services
- [x] Add a Grafana container ‚Üí create dashboards showing:

  - Number of notifications sent
  - HTTP request duration
  - Kafka message consumption rates

- [x] Add structured logging to both API & workers:

  - [x] Log request body, errors, and successful sends

- [] (Optional) Store notification logs in **PostgreSQL**

---

## **Phase 5: CI/CD + Cloud Deployment (Days 27‚Äì35)**

- [x] Create a Railway project
- [x] Deploy Notification API ‚Üí Railway
- [x] Deploy Email Worker & SMS Worker ‚Üí Railway
- [x] Migrate Kafka to Railway's managed add-on or use **Upstash Kafka**
- [x] Create `.env` or Railway environment variables for Mailgun/Twilio API keys
- [x] Write a **GitHub Actions workflow**:

  - [x] On `main` branch push ‚Üí Build Docker image ‚Üí Deploy to Railway
  - [x] Run Go unit tests in CI before deploying

- [x] Test cloud setup end-to-end: API call from Postman triggers real email/SMS via Railway-deployed services

---

## **Phase 6: Advanced Features (Optional)**

- [ ] Add a **Dashboard Worker** to consume events and save them in Postgres
- [ ] Build a simple frontend (React/Next.js) to display notification logs
- [ ] Add dead-letter queue topic & logic for failed notifications
- [ ] Add push notification support using Firebase Cloud Messaging
- [ ] Scale Kafka consumers by running multiple worker replicas in Docker Compose
- [ ] (Optional) Add tracing across services using OpenTelemetry & Jaeger

Version 2:

Awesome‚Äîlet‚Äôs turn this into a **learn-and-build roadmap** for an OSS, self-hostable notification platform (Signalbus++), plus the two reusable libraries you want (`gomailer` and `gosms`). It‚Äôs structured so you **learn a concept, then immediately build the thing that uses it**. I‚Äôve included detailed checklists you can literally check off as you go.

---

# üéØ What to learn first (practical prerequisites)

**Distributed systems & messaging**

- Kafka fundamentals: partitions, ordering, keys, consumer groups, offset commits, rebalancing, lag.
- Delivery semantics: at-least-once vs exactly-once (idempotent producer, transactional consumer), idempotency keys.
- Retry patterns: exponential backoff + jitter, DLQ, redrive, replay.

**Email core**

- SMTP vs API providers (Mailgun, SendGrid, SES, Postmark).
- MIME basics, plain vs HTML, attachments, inline images.
- Deliverability: SPF, DKIM, DMARC (what they are, why they matter).

**SMS core**

- E.164 phone number format, country routing.
- DLR (delivery receipts), webhooks, rate limits, cost awareness.

**Push & Chat**

- FCM (server key, device tokens, topics), APNs (p8 keys, JWT), Web Push (VAPID).
- Slack/Discord webhooks and formatting.

**API & security**

- REST design, OpenAPI/Swagger.
- API keys, HMAC request signing, idempotency keys.
- Secrets management, key rotation, per-tenant rate limiting.

**Persistence & schema**

- Modeling events, notification jobs, delivery attempts, tenants, templates.
- DB migrations (goose or golang-migrate).

**Observability**

- Prometheus metric design (cardinality!), Grafana dashboards.
- Distributed tracing with OpenTelemetry + collector.

**DevOps**

- Dockerfiles for small static Go images, multi-stage builds.
- Docker Compose for local, Helm for Kubernetes.
- CI/CD with GitHub Actions; lint (golangci-lint), tests, SBOM (syft), vuln scan (trivy).

**Testing**

- Unit tests with provider fakes.
- Contract tests against sandbox providers.
- Load test (k6) and chaos (toxiproxy).

---

# Integrated Learn ‚Üí Build roadmap

Each phase starts with **Learn**, then **Build** with concrete outcomes. Ship after every phase.

## Phase 0 ‚Äî Repo & skeleton (baseline)

**Learn**

- Monorepo organization, module boundaries, versioning.

**Build**

- Monorepo layout:

  ```
  /cmd
    /api
    /email-worker
    /sms-worker
    /push-worker
  /internal
    /notify   (domain models, routing)
    /providers/email
    /providers/sms
    /providers/push
    /db
    /metrics
    /auth
  /pkg
    /gomailer   (standalone module)
    /gosms      (standalone module)
  /deploy
    /docker
    /compose
    /helm
  /docs
  ```

- Tooling: go 1.22+, golangci-lint, pre-commit hooks, Makefile (`make test, lint, build, run`).
- `docker-compose.yml` with Kafka+Zookeeper/Redpanda, Postgres, Prometheus, Grafana, Mailpit (SMTP test inbox).

**Outcome**: `make up` boots full local stack with dashboards reachable.

---

## Phase 1 ‚Äî Email foundations & `gomailer`

**Learn**

- SMTP handshake, TLS, app passwords.
- API providers vs SMTP, deliverability trade-offs.

**Build**

1. **`pkg/gomailer` library**

   - `Mailer` interface: `Send(Email) error`.
   - Models: `Email{From, To, Subject, Text, HTML, Attachments}`.
   - Drivers:

     - **SMTP driver** (works with Gmail or any SMTP; test with Mailpit).
     - **Mailgun driver** (REST API).

   - Functional options (timeouts, headers), context support.
   - Idempotency (optional header pass-through).
   - Unit tests with fakes; example program in `/examples/gomailer`.

2. **Email worker (first real microservice)**

   - Kafka consumer group `notifications.email`.
   - Reads JSON `{id, tenant, to, subject, templates, data, idempotencyKey}`.
   - Uses `gomailer` with provider selection via config.
   - Retries (exponential + jitter), DLQ on permanent failure.
   - Prometheus metrics:

     - `notification_send_total{channel="email",provider,tenant,status}`
     - `notification_send_duration_seconds_bucket{channel="email",provider}`
     - `notification_retry_total{channel="email",reason}`

   - Logs in JSON (zap), correlation ID.

**Outcome**: `curl` ‚Üí Kafka ‚Üí Email worker ‚Üí message lands in Mailpit. Grafana shows counts & latency.

---

## Phase 2 ‚Äî SMS foundations & `gosms`

**Learn**

- E.164, provider APIs, DLR semantics, inbound webhooks.

**Build**

1. **`pkg/gosms`** with interface `Send(to, body)`.

   - Drivers: **Twilio** + **VHMAC proves body wasn‚Äôt tamperedonage** (config-switchable).
   - Normalize numbers to E.164; validate early.

2. **SMS worker**

   - Kafka consumer group `notifications.sms`.
   - Retry & DLQ like email; per-tenant throttle (simple token bucket in memory).
   - **DLR webhook** endpoint in API to mark ‚Äúdelivered/failed‚Äù asynchronously.

**Outcome**: End-to-end SMS via Twilio sandbox; delivery status flows back into DB via webhook.

---

## Phase 3 ‚Äî Notification API (publisher + admin)

**Learn**

- REST, OpenAPI; API keys & HMAC signing; idempotency.

**Build**

- `/publish/:topic` (generic) and `/notify` (policy-driven fan-out) endpoints.
- Request schema includes `idempotency_key`, tenant, user contact info, channel overrides, and template data.
- API Keys table (tenant, key hash, scopes, rate limit).
- Middlewares: auth, rate limit (token bucket), idempotency store (Redis or Postgres unique index).
- OpenAPI spec + Swagger UI.
- Producer: idempotent Kafka producer keyed by tenant+user to preserve per-user order.

**Outcome**: A single HTTP call can fan out to email+SMS topics, keys are validated, and duplicates are coalesced.

---

## Phase 4 ‚Äî Persistence & query surface

**Learn**

- DB schema versioning, indexing for search, SLOs on queries.

**Build**

- Tables:

  - `notifications(id, tenant, topic, user_ref, created_at, status)`
  - `delivery_attempts(id, notification_id, channel, provider, status, error, try, latency_ms, created_at)`
  - `api_keys(id, tenant, hash, scopes, created_at, last_used_at)`
  - `templates(id, tenant, channel, name, version, engine, content, created_at)`

- Repos + migrations (goose/golang-migrate).
- API:

  - `GET /notifications/:id`
  - `GET /notifications?tenant=&status=&channel=&user=&limit=&cursor=`
  - `POST /notifications/:id/redrive` (from DLQ)

  **Outcome**: You can see history and redrive failed ones.

---

## Phase 5 ‚Äî Templates, localization, preferences

**Learn**

- Go templates/Mustache, MJML ‚Üí HTML; i18n patterns; DND windows.

**Build**

- Template engine abstraction: `Render(channel, name, locale, data) (Text, HTML)`.
- Store templates in DB; optional filesystem loader for local dev.
- User preferences: opt-outs per channel, quiet hours (timezone aware).
- Policy engine: ‚Äúfor topic X ‚Üí channels \[email, sms] unless user opted-out‚Äù.

**Outcome**: Customizable content per tenant/locale with user-friendly opt-outs.

---

## Phase 6 ‚Äî Observability & tracing (deep)

**Learn**

- Metric cardinality limits, RED/USE metrics; OpenTelemetry spans.

**Build**

- Standard metrics in all services:

  - `http_requests_total{route,code}`
  - `kafka_consumer_lag{group,topic,partition}`
  - The channel metrics from earlier

- Tracing:

  - Span chain: API receive ‚Üí Kafka produce ‚Üí worker consume ‚Üí provider call.
  - OTel Collector + Jaeger/Tempo.

- Grafana dashboards:

  - API throughput, P95 latency.
  - Per-channel success/failure.
  - Kafka lag & rebalance count.
  - Provider latency compare (Mailgun vs SendGrid, Twilio vs Vonage).

**Outcome**: Click a trace and see the full lifecycle of one notification.

---

## Phase 7 ‚Äî Multi-tenant & quotas (SaaS-ready)

**Learn**

- Tenant isolation models, per-tenant quotas, noisy neighbor control.

**Build**

- Tenant scoping on reads/writes; row-level security rules (optional).
- Rate limit & quota counters by tenant.
- Usage meter: `tenant_usage_total{tenant,channel}`.
- Key rotation endpoints (create/revoke).

  **Outcome**: Safe to host multiple apps on one cluster.

---

## Phase 8 ‚Äî Push & Chat channels

**Learn**

- FCM topics & device tokens; APNs JWT; Web Push VAPID; Slack webhook payloads.

**Build**

- `gopush` abstraction: `Send(device, title, body, data)`.

  - Drivers: FCM (first), APNs, Web Push.

- Push worker: `notifications.push`.
- Slack worker: `notifications.slack` via webhook.
- Device token registry (user‚Üítokens) with expiration and cleanup.

**Outcome**: One publish can hit Email + SMS + Push + Slack.

---

## Phase 9 ‚Äî Reliability extras & ops

**Learn**

- Replay vs redrive; exactly-once with Kafka transactions (trade-offs); outbox pattern.

**Build**

- Replay tool: re-publish from a time window or by query.
- Redrive API from DLQ with optional re-templating.
- TTL for topics; compaction for idempotency keys.
- Lag alerts; KEDA autoscaling on consumer lag.

**Outcome**: Operable in the real world.

---

## Phase 10 ‚Äî Packaging, deployment, examples, docs

**Learn**

- Helm chart authoring; secrets; overlays; image hardening.

**Build**

- Minimal images (distroless or alpine), non-root user.
- `docker-compose` quickstart with Mailpit.
- Helm chart with values for providers, Postgres, Kafka endpoints.
- GitHub Actions: lint ‚Üí test ‚Üí build images ‚Üí SBOM ‚Üí scan ‚Üí push ‚Üí publish Helm chart.
- `/examples` clients in Go/Node/TS with a 10-line ‚Äúsend a notification‚Äù snippet.
- README with quickstart, architecture diagram, dashboards, and ‚Äúwhy‚Äù.

**Outcome**: Anyone can clone ‚Üí run ‚Üí send a notification in minutes.

---

### Phase 1 ‚Äî `gomailer` + Email worker

- [x] Define `Mailer` interface and `Email` model.
- [x] Implement **SMTP** driver (tested against Mailpit + Gmail app password).
- [x] Implement **Mailgun** driver.
- [x] Context timeouts, retries at library level (optional).
- [x] Unit tests with provider fakes; example CLI.
- [x] Email worker consumes `notifications.email` with retry + DLQ.
- [x] Prometheus metrics; JSON logs; config for primary/fallback provider.

### Phase 2 ‚Äî `gosms` + SMS worker

- [x] Define interface and Twilio+Vonage drivers.
- [ ] Normalize E.164 and validate.
- [ ] DLR webhook and status updates.
- [x] SMS worker with retry + DLQ + per-tenant rate limit.
- [x] Metrics
- [ ] Tests

### Phase 3 ‚Äî API

- [x] `/publish/:topic` and `/notify` (policy fan-out).
- [ ] API key auth
- [x] short term rate limit middleware.
- [ ] long term rate limit middleware.
- [x] Idempotency keys (DB unique index + cache).
- [ ] OpenAPI spec + Swagger UI.
- [ ] Idempotent Kafka producer keyed by user.

### Phase 4 ‚Äî Persistence

- [ ] Postgres schema for notifications, attempts, keys, templates.
- [ ] Migrations with goose/golang-migrate.
- [ ] `GET /notifications/:id` and search with pagination.
- [ ] `POST /notifications/:id/redrive`.

### Phase 5 ‚Äî Templates & prefs

- [x] Template storage; engines (Go tmpl + MJML pipeline).
- [ ] Localization field and selection.
- [ ] Opt-out table and DND windows (tz aware).
- [ ] Policy engine (topic ‚Üí channels, honoring prefs).

### Phase 6 ‚Äî Observability

- [ ] Standardize metrics names/labels.
- [ ] OTel tracing across services.
- [ ] Grafana dashboards for API, channels, Kafka lag, providers.
- [ ] Alerting rules for failure rates & lag.

### Phase 7 ‚Äî Multi-tenant

- [ ] Tenant column everywhere; scoped queries.
- [ ] Quotas & per-tenant rate limits.
- [ ] API key rotation endpoints.
- [ ] Usage metrics and basic billing counters.

### Phase 8 ‚Äî Push & Chat

- [ ] `gopush` with FCM (first), then APNs, Web Push.
- [ ] Push worker & token registry.
- [ ] Slack worker via webhook + formatting helpers.

### Phase 9 ‚Äî Reliability & ops

- [ ] Replay tool (time range / query).
- [ ] Redrive from DLQ with filter conditions.
- [ ] Topic compaction for idempotency keys.
- [ ] Autoscaling on lag (KEDA); lag/failure alerts.

### Phase 10 ‚Äî Packaging & docs

- [ ] Distroless images; non-root user.
- [ ] Helm chart with values; secrets guidance.
- [ ] GitHub Actions pipeline (lint/test/build/publish/scan).
- [ ] Examples in Go/Node/TS.
- [ ] README with diagram, quickstart, dashboards, and provider setup guides.
- [ ] CONTRIBUTING.md, CODE_OF_CONDUCT.md, Apache-2.0 license.

---

# Data & contract essentials (use early)

**Event (published)**

```json
{
  "id": "uuid",
  "tenant": "acme",
  "topic": "user.signup",
  "user": { "email": "a@b.com", "phone": "+1123", "tokens": ["fcmToken"] },
  "channels": ["email", "sms", "push"],
  "template": { "name": "welcome", "locale": "en-US" },
  "data": { "name": "Alice" },
  "idempotency_key": "uuid-or-hash",
  "created_at": "RFC3339"
}
```

**DeliveryAttempt (stored)**

- `attempt_id, notification_id, channel, provider, status(pending/sent/failed), try_no, error, latency_ms, created_at`

---

# Provider abstraction (mini blueprint)

**Email**

```go
type EmailProvider interface {
  Send(ctx context.Context, e Email) (ProviderMsgID string, err error)
}
```

**SMS**

```go
type SMSProvider interface {
  Send(ctx context.Context, to, body string) (ProviderMsgID string, err error)
}
```

**Push**

```go
type PushProvider interface {
  Send(ctx context.Context, token string, msg PushMessage) (ProviderMsgID string, err error)
}
```

**Provider registry**

```go
type ProviderFactory func(cfg map[string]string) (any, error)
// Register("email.mailgun", factory) ‚Üí config driven selection + fallback chain
```

---

# üß™ Testing plan (baked in every phase)

- Unit tests for providers with fakes (no network).
- Integration tests with Mailpit for SMTP; Twilio test creds; Redpanda for Kafka.
- k6 load test: publish 1k‚Äì10k events; assert success rate and P95.
- toxiproxy to inject latency/timeouts; assert retries + fallback.
- Golden tests for templates (rendered HTML/Text snapshots).

---

# Tooling you‚Äôll reuse

- **Kafka**: `segmentio/kafka-go` (you already use it).
- **Metrics**: `prometheus/client_golang`.
- **Tracing**: `go.opentelemetry.io/otel`.
- **Migrations**: `github.com/pressly/goose` or `github.com/golang-migrate/migrate`.
- **Lint**: `golangci-lint`.
- **Config**: `viper` or environment + struct tags.
- **Logging**: `uber-go/zap`.

---

## TL;DR build order (milestone view)

1. Skeleton + local stack ‚Üí `gomailer(SMTP+Mailgun)` ‚Üí Email worker
2. `gosms(Twilio+Vonage)` ‚Üí SMS worker + DLR
3. API (publish/notify, keys, idempotency)
4. Persistence & redrive
5. Templates, preferences, policy engine
6. Observability & tracing
7. Multi-tenant & quotas
8. Push & Slack
9. Replay/redrive tools, autoscaling
10. Helm, CI/CD, examples, docs

If you want, I can convert this into a **GitHub Project board (CSV/markdown)** with issues per task and acceptance criteria.
