
## Phase 1 — Email foundations & `gomailer`

**Learn**

- SMTP handshake, TLS, app passwords.
- API providers vs SMTP, deliverability trade-offs.

**Build**

1. **`pkg/gomailer` library**

   - `Mailer` interface: `Send(Email) error`.
   - Models: `Email{From, To, Subject, Text, HTML, Attachments}`.
   - Drivers:

     - **SMTP driver** (works with Gmail or any SMTP; test with Mailpit).
     - **Sendgrid driver** (REST API).

   - Functional options (timeouts, headers), context support.
   - Idempotency (optional header pass-through).
   - Unit tests with fakes; example program in `/examples/gomailer`.

2. **Email worker (first real microservice)**

   - Kafka consumer group `notifications.email`.
   - Reads JSON `{id, tenant, to, subject, templates, data, idempotencyKey}`.
   - Uses `gomailer` with provider selection via config.
   - Retries (exponential + jitter), DLQ on permanent failure.
   - Prometheus metrics:

     - `notification_send_total{channel="email",provider,tenant,status}`
     - `notification_send_duration_seconds_bucket{channel="email",provider}`
     - `notification_retry_total{channel="email",reason}`

   - Logs in JSON (zap), correlation ID.

**Outcome**: `curl` → Kafka → Email worker → message lands in Mailpit. Grafana shows counts & latency.

---

## Phase 2 — SMS foundations & `gosms`

**Learn**

- E.164, provider APIs, DLR semantics, inbound webhooks.

**Build**

1. **`pkg/gosms`** with interface `Send(to, body)`.

   - Drivers: **Twilio** + **VHMAC proves body wasn’t tamperedonage** (config-switchable).
   - Normalize numbers to E.164; validate early.

2. **SMS worker**

   - Kafka consumer group `notifications.sms`.
   - Retry & DLQ like email; per-tenant throttle (simple token bucket in memory).
   - **DLR webhook** endpoint in API to mark “delivered/failed” asynchronously.

**Outcome**: End-to-end SMS via Twilio sandbox; delivery status flows back into DB via webhook.

---

## Phase 3 — Notification API (publisher + admin)

**Learn**

- REST, OpenAPI; API keys & HMAC signing; idempotency.

**Build**

- `/publish/:topic` (generic) and `/notify` (policy-driven fan-out) endpoints.
- Request schema includes `idempotency_key`, tenant, user contact info, channel overrides, and template data.
- API Keys table (tenant, key hash, scopes, rate limit).
- Middlewares: auth, rate limit (token bucket), idempotency store (Redis or Postgres unique index).
- OpenAPI spec + Swagger UI.
- Producer: idempotent Kafka producer keyed by tenant+user to preserve per-user order.

**Outcome**: A single HTTP call can fan out to email+SMS topics, keys are validated, and duplicates are coalesced.

---

## Phase 4 — Persistence & query surface

**Learn**

- DB schema versioning, indexing for search, SLOs on queries.

**Build**

- Tables:

  - `notifications(id, tenant, topic, user_ref, created_at, status)`
  - `delivery_attempts(id, notification_id, channel, provider, status, error, try, latency_ms, created_at)`
  - `api_keys(id, tenant, hash, scopes, created_at, last_used_at)`
  - `templates(id, tenant, channel, name, version, engine, content, created_at)`

- Repos + migrations (goose/golang-migrate).
- API:

  - `GET /notifications/:id`
  - `GET /notifications?tenant=&status=&channel=&user=&limit=&cursor=`
  - `POST /notifications/:id/redrive` (from DLQ)

  **Outcome**: You can see history and redrive failed ones.

---

## Phase 5 — Templates, localization, preferences

**Learn**

- Go templates/Mustache, MJML → HTML; i18n patterns; DND windows.

**Build**

- Template engine abstraction: `Render(channel, name, locale, data) (Text, HTML)`.
- Store templates in DB; optional filesystem loader for local dev.
- User preferences: opt-outs per channel, quiet hours (timezone aware).
- Policy engine: “for topic X → channels \[email, sms] unless user opted-out”.

**Outcome**: Customizable content per tenant/locale with user-friendly opt-outs.

---

## Phase 6 — Observability & tracing (deep)

**Learn**

- Metric cardinality limits, RED/USE metrics; OpenTelemetry spans.

**Build**

- Standard metrics in all services:

  - `http_requests_total{route,code}`
  - `kafka_consumer_lag{group,topic,partition}`
  - The channel metrics from earlier

- Tracing:

  - Span chain: API receive → Kafka produce → worker consume → provider call.
  - OTel Collector + Jaeger/Tempo.

- Grafana dashboards:

  - API throughput, P95 latency.
  - Per-channel success/failure.
  - Kafka lag & rebalance count.
  - Provider latency compare (Mailgun vs SendGrid, Twilio vs Vonage).

**Outcome**: Click a trace and see the full lifecycle of one notification.

---

## Phase 7 — Multi-tenant & quotas (SaaS-ready)

**Learn**

- Tenant isolation models, per-tenant quotas, noisy neighbor control.

**Build**

- Tenant scoping on reads/writes; row-level security rules (optional).
- Rate limit & quota counters by tenant.
- Usage meter: `tenant_usage_total{tenant,channel}`.
- Key rotation endpoints (create/revoke).

  **Outcome**: Safe to host multiple apps on one cluster.

---

## Phase 8 — Push & Chat channels

**Learn**

- FCM topics & device tokens; APNs JWT; Web Push VAPID; Slack webhook payloads.

**Build**

- `gopush` abstraction: `Send(device, title, body, data)`.

  - Drivers: FCM (first), APNs, Web Push.

- Push worker: `notifications.push`.
- Slack worker: `notifications.slack` via webhook.
- Device token registry (user→tokens) with expiration and cleanup.

**Outcome**: One publish can hit Email + SMS + Push + Slack.

---

## Phase 9 — Reliability extras & ops

**Learn**

- Replay vs redrive; exactly-once with Kafka transactions (trade-offs); outbox pattern.

**Build**

- Replay tool: re-publish from a time window or by query.
- Redrive API from DLQ with optional re-templating.
- TTL for topics; compaction for idempotency keys.
- Lag alerts; KEDA autoscaling on consumer lag.

**Outcome**: Operable in the real world.

---

## Phase 10 — Packaging, deployment, examples, docs

**Learn**

- Helm chart authoring; secrets; overlays; image hardening.

**Build**

- Minimal images (distroless or alpine), non-root user.
- `docker-compose` quickstart with Mailpit.
- Helm chart with values for providers, Postgres, Kafka endpoints.
- GitHub Actions: lint → test → build images → SBOM → scan → push → publish Helm chart.
- `/examples` clients in Go/Node/TS with a 10-line “send a notification” snippet.
- README with quickstart, architecture diagram, dashboards, and “why”.

**Outcome**: Anyone can clone → run → send a notification in minutes.

---

### Phase 1 — `gomailer` + Email worker

- [x] Define `Mailer` interface and `Email` model.
- [x] Implement **SMTP** driver (tested against Mailpit + Gmail app password).
- [x] Implement **Mailgun** driver.
- [x] Context timeouts, retries at library level (optional).
- [x] Unit tests with provider fakes.
- [x] Email worker consumes `notifications.email` with retry + DLQ.
- [x] Prometheus metrics; JSON logs; config for primary/fallback provider.

### Phase 2 — `gosms` + SMS worker

- [x] Define interface and Twilio+Vonage drivers.
- [x] Normalize E.164 and validate.
- [ ] DLR webhook and status updates.
- [x] SMS worker with retry + DLQ + per-tenant rate limit.
- [x] Metrics
- [ ] Tests

### Phase 3 — API

- [x] `/publish/:topic` and `/notify` (policy fan-out).
- [x] API key auth
- [x] short term rate limit middleware.
- [x] long term rate limit middleware.
- [x] Idempotency keys (DB unique index + cache).
- [x] OpenAPI spec + Swagger UI.
- [x] Idempotent Kafka producer keyed by user.

### Phase 4 — Persistence

- [x] Postgres schema for notifications, attempts, keys, templates.
- [ ] Migrations with goose/golang-migrate.
- [x] `GET /notifications/:id` and search with pagination.
- [x] `POST /notifications/:id/redrive`.

### Phase 5 — Templates & prefs

- [x] Template storage; engines (Go tmpl)
- [ ] MJML pipeline.
- [x] Localization field and selection.
- [ ] Opt-out table and DND windows (tz aware).
- [x] Policy engine (topic → channels, honoring prefs).

### Phase 6 — Observability

- [x] Standardize metrics names/labels.
- [x] OTel tracing across services.
- [x] Grafana dashboards for API, channels, Kafka lag, providers.
- [x] Alerting rules for failure rates & lag.

### Phase 7 — Multi-tenant

- [x] Tenant column everywhere;
- [x] scoped queries.(almost)
- [x] Quotas & per-tenant rate limits.
- [ ] API key rotation endpoints.
- [ ] Usage metrics and basic billing counters.

### Phase 8 — Push & Chat

- [ ] `gopush` with FCM (first), then APNs, Web Push.
- [ ] Push worker & token registry.
- [ ] Slack worker via webhook + formatting helpers.

### Phase 9 — Reliability & ops

- [ ] Replay tool (time range / query).
- [ ] Redrive from DLQ with filter conditions.
- [ ] Topic compaction for idempotency keys.
- [ ] Autoscaling on lag (KEDA); lag/failure alerts.

### Phase 10 — Packaging & docs

- [ ] Distroless images; non-root user.
- [ ] Helm chart with values; secrets guidance.
- [ ] GitHub Actions pipeline (lint/test/build/publish/scan).
- [ ] Examples in Go/Node/TS.
- [ ] README with diagram, quickstart, dashboards, and provider setup guides.
- [ ] CONTRIBUTING.md, CODE_OF_CONDUCT.md, Apache-2.0 license.

---
